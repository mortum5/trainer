name = "Maps"
category = "easy"
default_code_snippet = """
func main() {
	var m map[int]bool
	fmt.Println(m)

	val, ok := m[1]
	fmt.Println(val, " ", ok)

	for i := 0; i < 5; i++ {
		m[i] = i%2 == 0
	}

	val, ok = m[1]
	fmt.Println(val, " ", ok)

	fmt.Println(m)

	var toPrint []int
	for key := range m {
		toPrint = append(toPrint, key)
	}

	fmt.Println(toPrint)

	delete(m, 2)
	fmt.Println(m)

	clear(m)
	fmt.Println(m)
}
"""
learning_advise = """
“Learning is never done without error, and defeat ” – Vladimir Lenin.
"""

[[learning_links]]
title = "Go blog about maps"
url = "https://go.dev/blog/maps"

[[learning_links]]
title = "Source code"
url = "https://go.dev/src/runtime/map.go"

[[learning_links]]
title = "Go by examples: Maps"
url = "https://gobyexample.com/maps"

[[questions]]
text = """Select the true statements and the line they refer to.
"""
type = "select_answers"
answers = [
    { text = "The map can be used without initialization" },
    { text = "The map can't be used without initialization", code_line_ranges = [[1]] },
    { text = "Access to not exists element will cause panic" },
    { text = "Calling this function may produce different results.", code_line_ranges = [[21]] },
    { text = "The clear function resets the element values ​and not resets the collection size" },
    { text = "The clear function resets the element values ​​and resets the collection size", code_line_ranges = [[26]] },
]

[[questions]]
text = """In Go, maps use buckets to store key-value pairs. 
Which of the following statements best describes how these buckets work?

"""
type = "select_answers"
answers = [
    { text = "Each bucket can store exactly one key-value pair" },
    { text = "Buckets use a linked list to store multiple key-value pairs that hash to the same bucket" },
    { text = "Buckets store key-value pairs in an array and resolve collisions using open addressing" },
    { text = "Buckets store key-value pairs in an array and use a linked list to handle collisions", code_line_ranges = [] },
]

[[questions]]
text = """What happens when the number of entries in a Go map exceeds a certain threshold?

"""
type = "select_answers"
answers = [
    { text = "The map allocates a new array with double the capacity and rehashes all keys" },
    { text = "The map remains the same size but uses a more sophisticated hash function" },
    { text = "The map splits existing buckets and rehashes only a portion of the keys", code_line_ranges = [] },
    { text = "The map creates a second, independent map and balances the keys between the two maps" },
]

[[questions]]
text = """The load factor of a map is a critical concept in understanding its efficiency. 
Which of the following best describes the load factor in the context of Go maps?

"""
type = "select_answers"
answers = [
    { text = "The ratio of the number of entries to the total capacity of the map" },
    { text = "The ratio of the number of used buckets to the total number of buckets" },
    { text = "The average number of key-value pairs stored in each bucket", code_line_ranges = [] },
    { text = "The ratio of the number of overflow buckets to the total number of buckets" },
]


[[questions]]
text = """How does the Go runtime handle memory management and garbage collection for maps, particularly regarding unused keys?

"""
type = "select_answers"
answers = [
    { text = "The Go runtime immediately reclaims memory for a map entry when a key is deleted" },
    { text = "The Go runtime marks deleted keys as unused, and the memory is reclaimed during the next garbage collection cycle", code_line_ranges = [] },
    { text = "The Go runtime never reclaims memory for deleted keys; the memory remains allocated until the entire map is garbage collected" },
    { text = "The Go runtime reclaims memory for deleted keys only when the map is resized" },
]


[[questions]]
text = """Why is the iteration order of keys in a Go map randomized?

"""
type = "select_answers"
answers = [
    { text = "To improve the performance of map operations by avoiding cache misses" },
    { text = "To ensure fairness in concurrent map access in multi-threaded programs" },
    { text = "To prevent programs from relying on a specific iteration order, which could lead to subtle bugs", code_line_ranges = [] },
    { text = "To enhance security by making it harder to predict the order of key-value pairs" },
]

[[questions]]
text = """Which of the following statements about the hash function used in Go maps is true?

"""
type = "select_answers"
answers = [
    { text = "Go uses a simple modulo operation to compute hash values for keys" },
    { text = "The hash function is deterministic and always produces the same hash for the same input across different runs" },
    { text = "The hash function includes a per-map random seed to protect against certain types of attacks", code_line_ranges = [] },
    { text = "Go maps do not use a hash function; they rely on direct indexing" },
]




